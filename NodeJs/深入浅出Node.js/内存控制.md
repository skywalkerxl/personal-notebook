---
date: 2018-10-27 09:31:09
title: 内存控制
tags: [NodeJS, 深入浅出Node.js]
categories: [NodeJS]
---

不论是浏览器端还是服务器端，内存控制都是一项十分重要的工作

## 一、V8垃圾回收机制与内存限制

### 1. Node 与 V8

Node 的出现得益于 V8 高性能虚拟机

### 2. V8 的内存限制

由于V8设计时的应用场景主要为浏览器环境，当V8运行在服务器环境下时，只有不到2G的内存限制就尤为突出，服务器上大量的内存资源得不到有效的使用，如果单 Node 进程触碰到了V8的内存限制，那么则会退出这个进程

### 3. V8的对象分配

在V8中，所有的 JavaScript 对象都是通过堆来进行内存分配的

JS 的内存空间分为栈（stack）、堆（heap）、池（一般也会归类为栈中），栈一般存放变量，堆一般存放复杂对象，池一般存放常量 [JavaScript 内存机制-掘金](https://juejin.im/post/5b10ba336fb9a01e66164346)

V8 会在一开始时申请一段堆内存控件，当申明变量时，所使用对象的内存就会分配在堆内存空间当中。如果已申请的堆内存不够新分配的对象，那么V8会再去申请一段新的内存空间，直到内存空间超过限制。

那么为何V8要对内存空间做限制呢？

原因时V8的垃圾回收机制所导致的，如果内存空间过大，那么一次垃圾回收所需要的时间就会很长

以1.5GB为例，垃圾回收一次的时间是50ms

而垃圾回收会暂停js的执行，这也就意味大的内存空间会带来糟糕的体验。

### 4. V8的垃圾回收机制

#### 垃圾回收算法

#### 1.内存分代

V8将内存分为新生代和老生代

#### 2. Scavenge 算法

![1540616870967](assets/1540616870967.png)

1. 我们将新生代内存分为两个部分： From 和 To
2. 我们新建一个对象时，会首先分配在 From 空间当中
3. 当进行一次垃圾回收时，如果 From 空间中的某些对象存活，那么我就将其复制到 To 内存空间当中，如果有非存活对象则将其释放
4. 再将 From 空间与 To 空间进行交换
5. 如果一个对象多次复制（多次垃圾回收）之后仍然存活，那我们就将其存放至老生代内存当中

![1540617741452](assets/1540617741452.png)

![1540617750611](assets/1540617750611.png)

从上面的两张图中，我们不难看出这是个晋升的过程，过程如下

`新生代 From 空间 ---> 新生代 To 空间 ---> 老生代空间`

#### 3. Mark-sweep & Mark-Compact

与上面的 `Scanvege` 算法复制活着的对象不同的是，`Mark-sweep` 是清理死亡的对象

`Mark-sweep` 对象并不会将内存分成多个部分，也就不会有浪费内存的现象

但是 `Mark-sweep` 会存在浪费内存的现象，会导致在分配大内存对象时，很难找到一整块满足的空间

于是便有了 `Mark-Compact`，他会将活着的对象往一边移动，移动之后便清理掉边界外的内存

![1540618774831](assets/1540618774831.png)



#### 4. Incremental Marking

`增量标记(incremental marking)`的作用是减少垃圾回收占据太长时间所带来的影响，他会让垃圾回收执行一段时间之后停一会，再执行一段时间后停一会... 

### 5.查看垃圾回收日志

启动时添加 `--trace_gc`

执行结束后在 `gc.log` 文件夹中查看垃圾回收信息



## 二、高效使用内存

这部分暂时不放在这里写了

### 1. 作用域

### 2. 闭包



## 三、内存指标

### 1. 查看内存的使用情况

#### 1). 查看进程的内存占用

使用 

1. `process.memoryUsage()`
2. `totalmem()`
3. `freemem()`

#### 2). 查看系统的内存占用

1. `os.totalmem()`
2. `os.freemem()`

![1540619893721](assets/1540619893721.png)

上面可以看出，内存共 8 GB 左右，闲置 4 GB 左右

### 2. 堆外内存

利用堆外内存可以突破V8堆内存的限制

我们也可以看到受 V8 限制的部分主要是V8的**堆内存**部分

## 四、内存泄露

造成内存泄露的原因如下

1. 缓存
2. 队列消费不及时（这里的消费应该是生产者-消费者中的消费概念）
3. 作用域未释放

解决方案如下:

1. 慎将内存做缓存
2. 关注队列状态



## 五、内存泄露排查

常用工具

* V8-profile
* node-heapdump
* node-mtrace
* dtrace
* node-memwatch



## 六、Node大内存应用

我们用 `fs.createReadStream()` 与 `fs.createWriteStream()` 方法通过流的方式实现对大文件的操作



